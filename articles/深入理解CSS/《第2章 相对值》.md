# 第2章 相对单位

像素单位（px）是绝对单位，即5px放在哪里都一样大。而其他单位，如em和rem，就不是绝对单位，而是相对单位。相对单位的值会根据外部因素发生变化。比如，2em的具体值会根据它作用到的元素（有时甚至是根据属性）而变化。因此相对单位的用法更难掌握。

## 2.1 相对值的好处

响应式——在CSS中指的是样式能够根据浏览器窗口的大小有不同的“响应”。这要求有意地考虑任何尺寸的手机、平板设备，或者桌面屏幕。

相对单位让我们可以基于窗口大小来等比例地缩放字号，而不是固定为14px，或者将网页上的任何元素的大小都相对于基础字号来设置，然后只用改一行代码就能缩放整个网页。下面来看看CSS是如何实现这些功能的。


**像素、点、派卡**

CSS支持几种绝对长度单位，最常用、最基础的是像素（px）。不常用的绝对单位是mm（毫米）、cm（厘米）、in（英寸）、pt（点，印刷术语，1/72英寸）、pc（派卡，印刷术语，12点）。这些单位都可以通过公式互相换算：1in = 25.4mm = 2.54cm = 6pc = 72pt = 96px。因此，16px等于12pt（16/96×72）。设计师经常用点作为单位，开发人员则习惯用像素。因此跟设计师沟通的时候需要做一些换算。

## 2.2 em和rem

em是最常见的相对长度单位，适合基于特定的字号进行排版。在CSS中，1em等于当前元素的字号，其准确值取决于作用的元素。

```
.padded {
  font-size: 16px;
  padding: 1em; //设置四个内边距为 font-size
}
```

这里设置内边距的值为1em。浏览器将其乘以字号，最终渲染为16px。这一点很重要：浏览器会根据相对单位的值计算出绝对值，称作计算值（computedvalue）。

当设置padding、height、width、border-radius等属性时，使用em会很方便。这是因为当元素继承了不同的字号，或者用户改变了字体设置时，这些属性会跟着元素均匀地缩放。

```
<span class="box box-small">Small</span>
<span class="box box-large">Large</span>

.box {
  padding: 1em;
  border-radius: 1em;
  background-color: lightgray;
}
.box-small {
  font-size: 12px;
}
.box-large {
  font-size: 18px;
}
```

### 2.2.1 使用em定义字号

如果声明font-size: 1.2em，会发生什么呢？一个字号当然不能等于自己的1.2倍。实际上，这个font-size是根据继承的字号来计算的。

```
<body>
  We love coffee
  <p class="slogan">We love coffee</p>
</body>

body {
  font-size: 16px;
}
.slogan {
  font-size: 1.2em; //继承了父元素body字号，计算结果为元素继承字号的1.2倍。
}
```

【注意】**如果知道字号的像素值，但是想用em声明，可以用一个简单的公式换算：用想要的像素大小除以父级（继承）的像素字号。比如，想要一个10px的字体，元素继承的字体是12px，则计算结果是10/12 =0.8333em。如果想要一个16px的字体，父级字号为12px，则计算结果是16/12 = 1.3333em。**

对大多数浏览器来说，默认的字号为16px。准确地说，medium关键字的值是16px。

**1. em同时用于字号和其他属性**

已经用em定义了字号（基于继承的字号），而且也用em定义了其他属性，比如padding和border-radius（基于当前元素的字号）。em的复杂之处在于同时用它指定一个元素的字号和其他属性。这时，浏览器必须先计算字号，然后使用这个计算值去算出其余的属性值。这两类属性可以拥有一样的声明值，但是计算值不一样。

```
body {
  font-size: 16px;
}
.slogan {
  font-size: 1.2em; // 16px * 1.2 = 19.2px
  padding: 1.2em; // 19.2 * 1.2 = 23.04px
  background-color: #ccc;
}
```

在这个例子里，padding的声明值为1.2em，乘以19.2px（当前元素的字号），得到计算值为23.04px。尽管font-size和padding的声明值相同，计算值却不一样。


**2. 字体缩小的问题**

当用em来指定多重嵌套的元素的字号时，就会产生意外的结果。为了算出每个元素的准确值，就需要知道继承的字号，如果这个值是在父元素上用em定义的，就需要知道父元素的继承值，以此类推，就会沿着DOM树一直往上查找。

当列表多级嵌套并且给每一级使用em定义字号时，就会发生文字缩小的现象。

em用在内边距、外边距以及元素大小上很好，但是用在字号上就会很复杂。值得庆幸的是，我们有更好的选择：rem。


### 2.2.2 使用rem设置字号

**rem是root em的缩写。rem不是相对于当前元素，而是相对于根元素的单位。不管在文档的什么位置使用rem,1.2rem都会有相同的计算值：1.2乘以根元素的字号。**

在文档中，根节点是所有其他元素的祖先节点。根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但是html的优先级相当于一个类名，而不是一个标签。

```
:root {
  font-size: 1em; // 使用浏览器默认字号（16px）
}
ul {
  font-size: .8rem; // 16px * 0.8 = 12.8px
}
```

根元素的字号为浏览器默认的字号16px（根元素上的em是相对于浏览器默认值的）。无序列表的字号设置为0.8rem，计算值为12.8px。因为相对根元素，所以所有字号始终一致，就算是嵌套列表也一样。


与em相比，rem降低了复杂性。实际上，rem结合了px和em的优点，既保留了相对单位的优势，又简单易用。那是不是应该全用rem，抛弃其他选择呢？答案是否定的。

在CSS里，答案通常是“看情况”。rem只是你工具包中的一种工具。掌握CSS很重要的一点是学会在适当的场景使用适当的工具。我一般会用rem设置字号，用px设置边框，用em设置其他大部分属性，尤其是内边距、外边距和圆角（不过我有时用百分比设置容器宽度）。

【注意】拿不准的时候，用rem设置字号，用px设置边框，用em设置其他大部分属性。

